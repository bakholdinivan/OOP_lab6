#include <iostream>
#include "Square.h"
#include "Rectangle.h"
#include "Trapezoid.h"
#include "Array.h"

/**
 * @file main.cpp
 * @brief Главная программа для работы с геометрическими фигурами
 */

using namespace std;

/**
 * @brief Выводит главное меню программы
 * 
 * Меню предоставляет все операции, требуемые по заданию:
 * - Добавление фигур (ввод из std::cin)
 * - Просмотр всех фигур с центрами и площадями
 * - Вычисление общей площади
 * - Удаление фигуры по индексу
 * - Сравнение фигур (оператор ==)
 * - Демонстрация копирования и перемещения
 */
void printMenu() {
    cout << "\n========== МЕНЮ ==========" << endl;
    cout << "1. Добавить квадрат" << endl;
    cout << "2. Добавить прямоугольник" << endl;
    cout << "3. Добавить трапецию" << endl;
    cout << "4. Показать все фигуры" << endl;
    cout << "5. Показать общую площадь" << endl;
    cout << "6. Удалить фигуру по индексу" << endl;
    cout << "7. Сравнить две фигуры" << endl;
    cout << "8. Демонстрация копирования/перемещения" << endl;
    cout << "0. Выход" << endl;
    cout << "==========================" << endl;
    cout << "Выберите действие: ";
}

/**
 * @brief Главная функция программы
 * @return 0 при успешном завершении
 * 
 * СТРУКТУРА:
 * 1. Создаем динамический массив фигур
 * 2. Показываем приветствие
 * 3. Входим в цикл обработки команд
 * 4. При выходе массив автоматически удалится (деструктор ~Array())
 */
int main() {
    // Создаем динамический массив для хранения фигур
    // Array хранит указатели Figure*, что позволяет использовать полиморфизм
    Array figures;
    

    cout << "=============================================" << endl;
    cout << "=============================================" << endl;
    
    int choice;  // Выбор пользователя
    
    // ===================================================================
    // ГЛАВНЫЙ ЦИКЛ ПРОГРАММЫ
    // ===================================================================
    while (true) {
        printMenu();
        cin >> choice;
        
        // Обработка ошибок ввода
        // Если пользователь ввел не число, cin.fail() вернет true
        if (cin.fail()) {
            cin.clear();                    // Сбрасываем флаг ошибки
            cin.ignore(10000, '\n');        // Игнорируем неверный ввод до конца строки
            cout << "Ошибка ввода!" << endl;
            continue;                       // Возвращаемся к началу цикла
        }
        
        // ===================================================================
        // ОБРАБОТКА КОМАНД
        // ===================================================================
        switch (choice) {
            // ===============================================================
            // СЛУЧАЙ 1: ДОБАВИТЬ КВАДРАТ
            // ===============================================================
            case 1: {
                // Создаем новый квадрат в динамической памяти
                // new возвращает указатель на созданный объект
                Square* sq = new Square();
                
                cout << "\nВведите координаты 4 вершин квадрата (x y):" << endl;
                cout << "Пример: 0 0 2 0 2 2 0 2" << endl;
                cout << "> ";
                
                // Используем перегруженный оператор >>
                // Это вызовет Square::read(), который считает 8 чисел
                cin >> *sq;
                
                // Добавляем квадрат в массив
                // ВАЖНО: массив берет владение указателем!
                // Не нужно вызывать delete вручную
                figures.push(sq);
                
                cout << "Квадрат добавлен! Площадь: " << sq->area() << endl;
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 2: ДОБАВИТЬ ПРЯМОУГОЛЬНИК
            // ===============================================================
            case 2: {
                Rectangle* rect = new Rectangle();
                
                cout << "\nВведите координаты 4 вершин прямоугольника (x y):" << endl;
                cout << "Пример: 0 0 4 0 4 2 0 2" << endl;
                cout << "> ";
                
                // Оператор >> вызовет Rectangle::read()
                cin >> *rect;
                
                figures.push(rect);
                cout << "Прямоугольник добавлен! Площадь: " << rect->area() << endl;
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 3: ДОБАВИТЬ ТРАПЕЦИЮ
            // ===============================================================
            case 3: {
                Trapezoid* trap = new Trapezoid();
                
                cout << "\nВведите координаты 4 вершин трапеции (x y):" << endl;
                cout << "Пример: 0 0 4 0 3 2 1 2" << endl;
                cout << "> ";
                
                // Оператор >> вызовет Trapezoid::read()
                cin >> *trap;
                
                figures.push(trap);
                cout << "Трапеция добавлена! Площадь: " << trap->area() << endl;
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 4: ПОКАЗАТЬ ВСЕ ФИГУРЫ
            // ===============================================================
            // Требование: "распечатывать для каждой фигуры в массиве
            //              геометрический центр и площадь"
            case 4: {
                cout << "\n=== Все фигуры ===" << endl;
                
                if (figures.size() == 0) {
                    cout << "Массив пуст. Добавьте фигуры через пункты 1-3." << endl;
                } else {
                    // Вызываем метод Array::printAll()
                    // Внутри используется полиморфизм:
                    // - для каждой фигуры вызываются ее методы print(), center(), area()
                    figures.printAll();
                }
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 5: ПОКАЗАТЬ ОБЩУЮ ПЛОЩАДЬ
            // ===============================================================
            // Требование: "вычислять общую площадь фигур в массиве"
            case 5: {
                cout << "\n=== Общая площадь всех фигур ===" << endl;
                
                // Вызываем Array::totalArea()
                // Внутри для каждой фигуры вызывается ее метод area()
                // благодаря полиморфизму
                double total = figures.totalArea();
                
                cout << "Общая площадь: " << total << endl;
                cout << "Количество фигур: " << figures.size() << endl;
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 6: УДАЛИТЬ ФИГУРУ ПО ИНДЕКСУ
            // ===============================================================
            // Требование: "удалять из массива фигуру по индексу"
            case 6: {
                cout << "\n=== Удаление фигуры ===" << endl;
                
                if (figures.size() == 0) {
                    cout << "Массив пуст. Нечего удалять." << endl;
                    break;
                }
                
                cout << "Введите индекс фигуры для удаления (0-" 
                     << figures.size() - 1 << "): ";
                int index;
                cin >> index;
                
                // Проверка корректности индекса
                if (index >= 0 && index < figures.size()) {
                    // Показываем удаляемую фигуру
                    Figure* fig = figures.get(index);
                    cout << "Удаляем: " << *fig << endl;
                    
                    // Удаляем фигуру
                    // Array::remove() освобождает память и сдвигает элементы
                    figures.remove(index);
                    
                    cout << "Фигура удалена!" << endl;
                } else {
                    cout << "Неверный индекс!" << endl;
                }
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 7: СРАВНИТЬ ДВЕ ФИГУРЫ
            // ===============================================================
            // Требование: "операции сравнения (==)"
            case 7: {
                cout << "\n=== Сравнение фигур ===" << endl;
                
                if (figures.size() < 2) {
                    cout << "Недостаточно фигур для сравнения!" << endl;
                    cout << "Добавьте хотя бы 2 фигуры." << endl;
                    break;
                }
                
                cout << "Введите индексы двух фигур для сравнения (например, 0 1): ";
                int i1, i2;
                cin >> i1 >> i2;
                
                // Проверка корректности индексов
                if (i1 >= 0 && i1 < figures.size() && 
                    i2 >= 0 && i2 < figures.size()) {
                    
                    Figure* fig1 = figures.get(i1);
                    Figure* fig2 = figures.get(i2);
                    
                    cout << "\nФигура 1: " << *fig1 << endl;
                    cout << "Фигура 2: " << *fig2 << endl;
                    cout << endl;
                    
                    // Используем перегруженный оператор ==
                    // Это вызовет Figure::operator==()
                    if (*fig1 == *fig2) {
                        cout << "Результат: Фигуры РАВНЫ (совпадают все вершины)" << endl;
                    } else {
                        cout << "Результат: Фигуры НЕ РАВНЫ" << endl;
                    }
                } else {
                    cout << "Неверные индексы!" << endl;
                }
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 8: ДЕМОНСТРАЦИЯ КОПИРОВАНИЯ И ПЕРЕМЕЩЕНИЯ
            // ===============================================================
            // Требование: "операции копирования (=), перемещения (=)"
            case 8: {
                cout << "\n=== Демонстрация операций копирования и перемещения ===" << endl;
                
                // Создаем квадрат 2x2
                Point p[4] = {Point(0, 0), Point(2, 0), Point(2, 2), Point(0, 2)};
                Square sq1(p);
                cout << "\n1. Создан sq1: " << sq1 << " | Площадь: " << (double)sq1 << endl;
                
                // -------------------------------------------------------
                // КОПИРОВАНИЕ ЧЕРЕЗ КОНСТРУКТОР
                // -------------------------------------------------------
                // Вызовется Square::Square(const Square&)
                Square sq2(sq1);
                cout << "\n2. Копирование через конструктор: Square sq2(sq1)" << endl;
                cout << "   sq2: " << sq2 << " | Площадь: " << (double)sq2 << endl;
                cout << "   sq1 и sq2 - независимые объекты" << endl;
                
                // -------------------------------------------------------
                // КОПИРОВАНИЕ ЧЕРЕЗ ОПЕРАТОР =
                // -------------------------------------------------------
                // Вызовется Square::operator=(const Square&)
                Square sq3;
                sq3 = sq1;
                cout << "\n3. Копирование через оператор =: sq3 = sq1" << endl;
                cout << "   sq3: " << sq3 << " | Площадь: " << (double)sq3 << endl;
                
                // -------------------------------------------------------
                // ПЕРЕМЕЩЕНИЕ ЧЕРЕЗ КОНСТРУКТОР
                // -------------------------------------------------------
                // Вызовется Square::Square(Square&&)
                // std::move() явно преобразует lvalue в rvalue
                Square sq4(std::move(sq1));
                cout << "\n4. Перемещение через конструктор: Square sq4(std::move(sq1))" << endl;
                cout << "   sq4: " << sq4 << " | Площадь: " << (double)sq4 << endl;
                cout << "   Данные 'переехали' из sq1 в sq4" << endl;
                
                // -------------------------------------------------------
                // ПЕРЕМЕЩЕНИЕ ЧЕРЕЗ ОПЕРАТОР =
                // -------------------------------------------------------
                // Вызовется Square::operator=(Square&&)
                Square sq5;
                sq5 = std::move(sq2);
                cout << "\n5. Перемещение через оператор =: sq5 = std::move(sq2)" << endl;
                cout << "   sq5: " << sq5 << " | Площадь: " << (double)sq5 << endl;
                
                // -------------------------------------------------------
                // СРАВНЕНИЕ
                // -------------------------------------------------------
                cout << "\n6. Сравнение:" << endl;
                if (sq3 == sq4) {
                    cout << "   sq3 == sq4: РАВНЫ (вершины совпадают)" << endl;
                }
                if (sq4 == sq5) {
                    cout << "   sq4 == sq5: РАВНЫ (вершины совпадают)" << endl;
                }
                
                cout << "\nДемонстрация завершена." << endl;
                break;
            }
            
            // ===============================================================
            // СЛУЧАЙ 0: ВЫХОД
            // ===============================================================
            case 0:
                cout << "\nПрограмма завершена." << endl;
                // При выходе из main автоматически вызовется ~Array()
                // который удалит все фигуры и освободит память
                return 0;
            
            // ===============================================================
            // НЕВЕРНЫЙ ВЫБОР
            // ===============================================================
            default:
                cout << "Неверный выбор!" << endl;
        }
    }
    
    return 0;
}