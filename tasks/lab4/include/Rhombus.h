#pragma once
#include "Figure.h"


// КЛАСС РОМБ

// Наследуется от Figure<T> 
// Ромб - это четырёхугольник, все стороны которого равны
// Характеристики:
// - 4 вершины
// - Все 4 стороны имеют одинаковую длину
// - Противоположные углы равны
// - Диагонали перпендикулярны и делят друг друга пополам
// - Является параллелограммом
// - Частный случай: квадрат (ромб с прямыми углами)
template<Scalar T>
class Rhombus : public Figure<T> {
public:
    
    // Конструктор дефолтный
   
    // Создаёт ромб с диагоналями вдоль осей координат
    // Вершины: (2,0), (0,1), (-2,0), (0,-1)
    // Диагонали: горизонтальная длиной 4, вертикальная длиной 2
    Rhombus() {
        // Резервируем память для 4 вершин

        this->points.reserve(4);
        
        // Создаём вершины ромба, расположенные симметрично относительно начала координат
        // static_cast<T> - явное преобразование типа (int -> T)
        // Необходимо, т.к. литерал 2 имеет тип int
        this->points.push(std::make_unique<Point<T>>(static_cast<T>(2), T{}));
        this->points.push(std::make_unique<Point<T>>(T{}, static_cast<T>(1)));
        this->points.push(std::make_unique<Point<T>>(static_cast<T>(-2), T{}));
        this->points.push(std::make_unique<Point<T>>(T{}, static_cast<T>(-1)));
        
        // Сортируем вершины против часовой стрелки
        // Важно для формулы Гаусса при вычислении площади
        this->sortPoints();
    }
    

    // Конструктор из набора точек

    // Позволяет создать ромб с произвольными координатами вершин
    // pts - массив точек (должен содержать 4 элемента)
    // n - размер массива
    Rhombus(const Point<T>* pts, size_t n) {
        // Проверка количества вершин

        if (n != 4) {
            throw std::invalid_argument("Ромб должен иметь 4 вершины");
        }
        
        this->points.reserve(4);
        
        // Копируем точки из входного массива в наш массив unique_ptr
        for (size_t i = 0; i < n; ++i) {
            // Создаём новый Point копированием из pts[i]
            this->points.push(std::make_unique<Point<T>>(pts[i]));
        }
        
        // Упорядочиваем вершины
        this->sortPoints();
    }
    
  
    // Переопределяем виртуальные методы



    
    // Вычисление площади ромба
    // Формула: S = (d1 * d2) / 2, где d1, d2 - длины диагоналей
    // Но мы используем универсальную формулу Гаусса из базового класса
    T area() const override { 
        return this->calculateArea(); 
    }
    
    // Вычисление центра ромба
    // Для ромба центр = точка пересечения диагоналей = среднее вершин
    Point<T> center() const override { 
        return this->calculateCenter(); 
    }
    

    // Выводим информацию

    // Этот метод вызывается полиморфно через указатель на базовый класс

    void print(std::ostream& os) const override {
        os << "Rhombus: ";  // Тип фигуры
        
        // Выводим координаты всех вершин
        for (size_t i = 0; i < this->points.size(); ++i) {
            // *this->points[i] - разыменовываем unique_ptr, получаем Point&
            // Затем вызывается Point::operator<<
            os << *this->points[i];
            
            // Добавляем пробел между точками (кроме последней)
            if (i < this->points.size() - 1) os << " ";
        }
    }
    
    // Возвращает строковое представление типа
    // Используется для отладки и информационных сообщений
    const char* getType() const override { 
        return "Rhombus"; 
    }
};